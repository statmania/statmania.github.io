<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocabulary Flashcards</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <style>
        /* Custom CSS for 3D Flip Effect */
        #flashcard {
            width: 100%; /* Take full width of parent column */
            max-width: 400px;
            height: 250px;
            perspective: 1000px;
        }

        .flashcard-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            cursor: pointer;
            box-shadow: 0 10px 25px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
            border-radius: 1rem;
        }

        .flashcard-inner.flipped {
            transform: rotateY(180deg);
        }

        .flashcard-front, .flashcard-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 1.5rem;
            border-radius: 1rem;
            background-color: #ffffff;
        }

        /* Dark Mode support */
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #1f2937; /* Gray-800 */
            }
            .flashcard-front, .flashcard-back {
                background-color: #374151; /* Gray-700 */
                color: #f3f4f6; /* Gray-100 */
            }
            .flashcard-back h3, .flashcard-back p {
                color: #d1d5db; /* Gray-300 */
            }
        }

        .flashcard-front {
            background-color: #eff6ff; /* Blue-50 */
        }

        .flashcard-front h2 {
            font-size: 2.5rem;
            font-weight: 700;
            color: #1e3a8a; /* Blue-800 */
            text-align: center;
        }

        .flashcard-back {
            transform: rotateY(180deg);
            background-color: #f9fafb; /* Gray-50 */
            text-align: left;
            padding: 2rem;
        }

        .flashcard-back h3 {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 0.5rem;
        }

        .flashcard-back p {
            font-size: 0.9rem;
            color: #4b5563;
            margin-bottom: 0.75rem;
            line-height: 1.4;
        }

        /* Responsive adjustments */
        @media (max-width: 640px) {
            #flashcard {
                height: 300px;
                max-width: 95vw;
            }
            .flashcard-front h2 {
                font-size: 2rem;
            }
        }

        /* Styles for the side navigation buttons */
        .side-nav-button {
            width: 100px; /* Fixed width for better visual balance */
            height: 50px; /* Ensures a good touch target */
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4" style="font-family: 'Inter', sans-serif;">

    <h1 class="text-3xl font-bold text-gray-800 mb-6 dark:text-gray-100">
        Vocabulary Flashcards
    </h1>

    <!-- Filter Menu (Letter Dropdown and Serial Range) -->
    <div class="w-full max-w-4xl mb-6 p-4 bg-white rounded-xl shadow-lg dark:bg-gray-800 border border-gray-200 dark:border-gray-700">
        <h3 class="text-xl font-bold text-gray-700 mb-4 dark:text-gray-300">Filter Options</h3>

        <div class="flex flex-col sm:flex-row gap-4">
            <!-- Letter Filter Dropdown -->
            <div class="flex-1">
                <label for="letterFilterSelect" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Filter by Initial Letter:</label>
                <select id="letterFilterSelect" onchange="applyFilters()"
                    class="w-full p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white">
                    <option value="ALL">ALL Words</option>
                    <!-- Options will be generated by JavaScript -->
                </select>
            </div>

            <!-- Serial Range Filter -->
            <div class="flex-1">
                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Filter by Word Serial Index:</label>
                <div class="flex items-center space-x-2">
                    <input type="number" id="startSerial" placeholder="From (e.g., 1)"
                           class="w-1/3 p-2 border border-gray-300 rounded-lg shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white min-w-0" min="1">
                    <span class="text-gray-500 dark:text-gray-400">to</span>
                    <input type="number" id="endSerial" placeholder="To (e.g., 50)"
                           class="w-1/3 p-2 border border-gray-300 rounded-lg shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white min-w-0">
                    <button onclick="applyFilters()"
                            class="w-1/3 p-2 bg-indigo-500 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-600 transition duration-300 whitespace-nowrap min-w-max">
                        Apply
                    </button>
                </div>
                <p id="wordCountMessage" class="mt-2 text-xs text-gray-500 dark:text-gray-400">Total words: 0. Showing: 0</p>
            </div>
        </div>
    </div>
    <!-- End Filter Menu -->

    <!-- Top Control Bar (Home Link and Shuffle Button) - CENTERED ABOVE CARD -->
    <div class="w-full max-w-4xl mb-6 flex justify-center items-center px-2 sm:px-0">
        <div class="flex space-x-6"> <!-- Use space-x-6 for spacing between elements -->
            <!-- Home Link (Updated URL) -->
            <a href="../" class="px-4 py-2 text-indigo-600 hover:text-indigo-800 font-semibold rounded-full transition duration-300 text-sm sm:text-base">
                <i class="fas fa-home mr-1"></i> Home
            </a>
            <!-- Shuffle Button -->
            <button id="shuffleButton" onclick="shuffleCards()" class="px-4 py-2 bg-yellow-500 text-white font-semibold rounded-full shadow-lg hover:bg-yellow-600 transition duration-300 disabled:opacity-50 text-sm sm:text-base">
                <i class="fas fa-random mr-2"></i> Shuffle
            </button>
        </div>
    </div>
    <!-- End Top Control Bar -->

    <!-- Main Card & Navigation Container -->
    <div class="flex items-center justify-center w-full max-w-4xl mb-8">

        <!-- Previous Word Button (Left) -->
        <button id="previousCardButton" onclick="loadPreviousCard()"
            class="side-nav-button mr-4 p-2 bg-gray-500 text-white font-semibold rounded-full shadow-lg hover:bg-gray-600 transition duration-300 disabled:opacity-50 text-xl flex items-center justify-center sm:text-2xl"
            disabled title="Previous Word">
            <i class="fas fa-arrow-left"></i>
        </button>

        <!-- Flashcard -->
        <div id="flashcard" touch-action="none">
            <div id="cardInner" class="flashcard-inner" onclick="flipCard()">
                <!-- Card Front -->
                <div id="cardFront" class="flashcard-front">
                    <!-- loadingText is visible by default -->
                    <p id="loadingText" class="text-lg text-gray-500">Loading Words...</p>
                    <!-- mainWord is hidden by default, shown once data loads -->
                    <h2 id="mainWord" class="hidden"></h2>
                </div>

                <!-- Card Back -->
                <div id="cardBack" class="flashcard-back">
                    <h3 class="text-sm uppercase tracking-wider text-gray-400 mb-2">Definition & Usage</h3>
                    <p id="partOfSpeech" class="font-bold text-indigo-600">Part of Speech: <span id="posContent"></span></p>
                    <p id="meaningText" class="text-gray-700">Meaning: <span id="meaningContent"></span></p>
                    <p id="exampleText" class="italic text-gray-500 border-t border-gray-200 pt-3 mt-3">
                        <span class="font-bold not-italic text-sm text-gray-800">Example:</span> <span id="exampleContent"></span>
                    </p>
                </div>
            </div>
        </div>

        <!-- Next Word Button (Right) -->
        <button id="nextCardButton" onclick="loadNextCard()"
            class="side-nav-button ml-4 p-2 bg-indigo-600 text-white font-semibold rounded-full shadow-lg hover:bg-indigo-700 transition duration-300 disabled:opacity-50 text-xl flex items-center justify-center sm:text-2xl"
            title="Next Word">
            <i class="fas fa-arrow-right"></i>
        </button>
    </div>
    <!-- End Main Card & Navigation Container -->

    <script>
        // MOCK DATA: Used for immediate functionality since we cannot access local files.
        const MOCK_CSV_DATA = `
word,meaning,part_of_speech,example
ephemeral,"lasting for a very short time",adjective,"The beauty of the cherry blossoms is ephemeral, lasting only a few weeks."
insipid,"lacking flavor or zest; dull",adjective,"The film was insipid, with a predictable plot and uninspired acting."
obfuscate,"to make obscure, unclear, or unintelligible",verb,"The politician attempted to obfuscate the issue with vague responses."
capricious,"given to sudden and unaccountable changes of mood or behavior",adjective,"The investors were wary of the CEO's capricious decision-making."
serendipity,"the occurrence and development of events by chance in a happy or beneficial way",noun,"Finding the lost ring was a moment of pure serendipity."
alacrity,"brisk and cheerful readiness",noun,"She accepted the new assignment with alacrity."
tenuous,"very weak or slight",adjective,"The tenuous link between the evidence and the suspect quickly broke down."
paradox,"a seemingly absurd or self-contradictory statement or proposition that when investigated or explained may prove to be well founded or true",noun,"The paradox is that the more you give, the more you have."
ubiquitous,"present, appearing, or found everywhere",adjective,"Smartphones are ubiquitous in modern society."
zeitgeist,"the defining spirit or mood of a particular period of history as shown by the ideas and beliefs of the time",noun,"The film perfectly captured the liberal zeitgeist of the 1960s."
juxtaposition,"the fact of two things being seen or placed close together with contrasting effect",noun,"The juxtaposition of the old church and the new skyscraper was striking."
bifurcate,"divide into two branches or forks",verb,"The road bifurcates near the river."
deleterious,"causing harm or damage",adjective,"The lack of sleep had a deleterious effect on his focus."
fecund,"producing or capable of producing an abundance of offspring or new growth; fertile",adjective,"The artist's fecund imagination produced masterpiece after masterpiece."
garrulous,"excessively talkative, especially on trivial matters",adjective,"The garrulous taxi driver kept recounting tales of his youth."
`;

        const CSV_URL = 'magoosh_az_words.csv';

        let allWords = [];
        let filteredWords = [];
        let currentWordIndex = -1;
        let wordHistory = [];
        const ALPHABET = Array.from({ length: 26 }, (_, i) => String.fromCharCode(65 + i));

        // --- CSV Parsing Function (unchanged) ---
        const parseCSV = (text) => {
            try {
                const lines = text.trim().split('\n').filter(line => line.length > 0);
                if (lines.length <= 1) return [];

                const headers = lines[0].split(',').map(h => h.trim());
                const dataLines = lines.slice(1);
                const results = [];

                dataLines.forEach(line => {
                    const values = [];
                    let value = '';
                    let inQuotes = false;
                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];

                        if (char === '"') {
                            inQuotes = !inQuotes;
                        } else if (char === ',' && !inQuotes) {
                            values.push(value.trim().replace(/^"|"$/g, ''));
                            value = '';
                        } else {
                            value += char;
                        }
                    }
                    values.push(value.trim().replace(/^"|"$/g, ''));

                    if (values.length === headers.length) {
                        const row = {};
                        headers.forEach((header, index) => {
                            row[header] = values[index];
                        });
                        results.push(row);
                    } else {
                        console.warn('Skipping malformed row:', line);
                    }
                });
                return results;

            } catch (error) {
                console.error("Error parsing CSV data:", error);
                return [];
            }
        };

        // --- Core Application Logic ---

        // Helper function for Fisher-Yates shuffle
        const shuffleArray = (array) => {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        };

        window.shuffleCards = function() {
            if (filteredWords.length > 0) {
                shuffleArray(filteredWords);
                currentWordIndex = 0;
                wordHistory = [];
                loadCard(currentWordIndex, true);
            }
        };

        // Combines both letter and serial range filters
        window.applyFilters = function() {
            const letter = document.getElementById('letterFilterSelect').value;
            const totalWords = allWords.length;

            // 1. DETERMINE SERIAL RANGE (1-based, inclusive)
            // Read values and use defaults if empty or invalid
            let start = parseInt(document.getElementById('startSerial').value);
            let end = parseInt(document.getElementById('endSerial').value);

            // Set defaults and clamp values
            // If start is invalid, default to 1
            start = (isNaN(start) || start < 1) ? 1 : start;
            // If end is invalid, default to totalWords, ensuring it doesn't exceed totalWords
            end = (isNaN(end) || end > totalWords) ? totalWords : end;

            // Ensure valid range order (end is not before start)
            if (end < start) end = start;

            // Convert 1-based inclusive range to 0-based slice indices
            const startIndex = start - 1;
            const endIndex = end; // slice() end is exclusive, so 'end' is correct

            // 2. APPLY SERIAL RANGE FILTER
            // Get the subset based on the serial index from the full word list
            let rangeWords = allWords.slice(startIndex, endIndex);

            // 3. APPLY LETTER FILTER to the range-limited words
            if (letter !== 'ALL') {
                 filteredWords = rangeWords.filter(word => word.word && word.word.toUpperCase().startsWith(letter));
            } else {
                filteredWords = rangeWords; // Letter filter is 'ALL', use the rangeWords directly
            }

            // 4. Update UI Messages and State
            const wordCountMessage = document.getElementById('wordCountMessage');
            // Display the actual range used (start and end from the validated inputs)
            wordCountMessage.textContent = `Total words: ${totalWords}. Showing: ${filteredWords.length} (Serial ${start} to ${end}).`;


            // --- 5. Reset Card View ---
            currentWordIndex = -1;
            wordHistory = [];

            const loadingText = document.getElementById('loadingText');
            const mainWord = document.getElementById('mainWord');

            if (filteredWords.length > 0) {
                currentWordIndex = 0;
                loadCard(currentWordIndex, true);

                loadingText.classList.add('hidden');
                mainWord.classList.remove('hidden');
            } else {
                mainWord.classList.add('hidden');
                loadingText.textContent = `No words found matching the current filters.`;
                loadingText.classList.remove('hidden');
            }
            updateButtonStates();
        };

        // Loads the details of the word at the given index
        const loadCard = (index, trackHistory = true) => {
            // 1. Ensure card is facing front
            document.getElementById('cardInner').classList.remove('flipped');

            const wordData = filteredWords[index];

            if (trackHistory) {
                 if (wordHistory.length === 0 || wordHistory[wordHistory.length - 1] !== index) {
                    wordHistory.push(index);
                 }
            }

            if (wordHistory.length > 50) {
                wordHistory.shift();
            }

            // 2. Update the Card Front (Word)
            document.getElementById('mainWord').textContent = wordData.word || 'N/A';

            // 3. Update the Card Back (Details)
            document.getElementById('posContent').textContent = wordData.part_of_speech || 'N/A';
            document.getElementById('meaningContent').textContent = wordData.meaning || 'N/A';
            document.getElementById('exampleContent').textContent = wordData.example || 'N/A';

            updateButtonStates();
        }

        // Handles loading the next card, wrapping around the list
        window.loadNextCard = function() {
            if (filteredWords.length === 0) {
                updateButtonStates();
                return;
            }

            currentWordIndex = (currentWordIndex + 1) % filteredWords.length;

            loadCard(currentWordIndex, true);
        };

        // Loads the previous card using the history array
        window.loadPreviousCard = function() {
            if (wordHistory.length > 1) {
                wordHistory.pop();
                const previousIndex = wordHistory[wordHistory.length - 1];

                currentWordIndex = previousIndex;
                loadCard(currentWordIndex, false);
            } else {
                updateButtonStates();
            }
        };

        // Updates the disabled state of the navigation buttons
        const updateButtonStates = () => {
            document.getElementById('previousCardButton').disabled = wordHistory.length <= 1 || filteredWords.length === 0;
            document.getElementById('nextCardButton').disabled = filteredWords.length === 0;
            document.getElementById('shuffleButton').disabled = filteredWords.length === 0;
        };

        // Generates the filter UI (Dropdown Options)
        const generateFilterUI = () => {
            const selectElement = document.getElementById('letterFilterSelect');

            // Clear existing options (if any beyond "ALL Words")
            while (selectElement.options.length > 1) {
                selectElement.remove(1);
            }

            // Add A-Z alphabet options
            ALPHABET.forEach(letter => {
                const option = document.createElement('option');
                option.value = letter;
                option.textContent = letter;
                selectElement.appendChild(option);
            });
        };


        // --- Data Loading and Initialization ---
        const loadWords = async () => {
            const loadingText = document.getElementById('loadingText');
            const mainWord = document.getElementById('mainWord');

            loadingText.classList.remove('hidden');
            mainWord.classList.add('hidden');
            loadingText.textContent = 'Loading Words...';

            let csvText = MOCK_CSV_DATA;

            try {
                const response = await fetch(CSV_URL);
                if (!response.ok) {
                    throw new Error(`Status: ${response.status} ${response.statusText}`);
                }
                csvText = await response.text();
            } catch (error) {
                console.warn(`Failed to fetch file at '${CSV_URL}'. Using Mock Data.`);
            }

            allWords = parseCSV(csvText);
            allWords = allWords.filter(word => word.word && word.word.trim() !== '');

            // Initialize filter UI (must be done before applying initial filter)
            generateFilterUI();

            if (allWords.length > 0) {
                // Set initial inputs for the range filter to show all words
                document.getElementById('startSerial').value = 1;
                document.getElementById('endSerial').value = allWords.length;

                // Apply initial filters (which defaults to ALL and full range)
                applyFilters();

            } else {
                loadingText.textContent = 'No valid word data found.';
                loadingText.classList.remove('hidden');
                mainWord.classList.add('hidden');
                document.getElementById('nextCardButton').disabled = true;
                document.getElementById('shuffleButton').disabled = true;
            }
            updateButtonStates();
        };

        window.flipCard = function() {
            const cardInner = document.getElementById('cardInner');
            cardInner.classList.toggle('flipped');
        }

        // --- Swipe Navigation Logic for Mobile ---
        let touchstartX = 0;
        let touchendX = 0;
        const SWIPE_THRESHOLD = 75;

        function handleGesture() {
            const diffX = touchendX - touchstartX;

            if (Math.abs(diffX) > SWIPE_THRESHOLD) {
                if (diffX < 0) {
                    // Swiped Left (Next Card)
                    window.loadNextCard();
                } else {
                    // Swiped Right (Previous Card)
                    window.loadPreviousCard();
                }
            }
        }

        const cardElement = document.getElementById('flashcard');

        cardElement.addEventListener('touchstart', e => {
            touchstartX = e.changedTouches[0].screenX;
        });

        cardElement.addEventListener('touchend', e => {
            touchendX = e.changedTouches[0].screenX;
            handleGesture();
        });

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', loadWords);

    </script>
</body>
</html>
