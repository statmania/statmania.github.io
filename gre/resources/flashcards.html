<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stat Mania GRE Flashcards</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <style>
        /* Custom CSS for 3D Flip Effect */
        #flashcard {
            width: 100%;
            max-width: 400px;
            /* New desktop height: increased from 290px to 310px (approx 5% more) */
            height: 310px;
            perspective: 1000px;
        }

        .flashcard-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            cursor: pointer;
            box-shadow: 0 10px 25px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
            border-radius: 1rem;
        }

        .flashcard-inner.flipped {
            transform: rotateY(180deg);
        }

        /* Card Front & Back base styles: Non-white colors */
        .flashcard-front, .flashcard-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 1.5rem;
            border-radius: 1rem;
            /* Light Indigo/Lavender tint for card front base */
            background-color: #eef2ff;
            z-index: 1;
            transition: background-color 0.3s;
        }

        /* Card Back Styling: Slightly different light color for back */
        .flashcard-back {
            transform: rotateY(180deg);
            /* Very Light Cyan/Mint tint for card back base */
            background-color: #f0fdfa;
            z-index: 2;
            display: flex;
            flex-direction: column;
            padding: 1rem;
        }

        /* Scrollable Content Area: Text is centered here */
        .card-content-scroll {
            flex-grow: 1;
            overflow-y: auto;
            text-align: center;
            padding: 1rem;
        }

        /* --- Beautified Card Back Content Styles --- */

        /* Styling for Meaning content (main definition) - Light Teal Background */
        p#meaningContent {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1f2937;

            background-color: #e0f2f1; /* Light Teal/Cyan for meaning block */
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            margin-bottom: 1.5rem;
            line-height: 1.4;
        }

        /* Styling for Example content - Light Red Background */
        p#exampleContent {
            font-size: 0.95rem;
            font-style: italic;
            color: #4b5563;

            background-color: #fee2e2; /* Light Red/Pink for example block */
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);

            margin-top: 0.5rem;
            margin-bottom: 0;
            line-height: 1.5;
        }

        /* Dark Mode support */
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #1f2937; /* Gray-800 - Page background */
            }

            /* Dark, non-gray/black card bases */
            .flashcard-front {
                background-color: #1e1b4b; /* Dark Indigo-950 */
                color: #f3f4f6;
            }
            .flashcard-back {
                background-color: #134e4a; /* Dark Teal-800 */
                color: #f3f4f6;
            }

            .flashcard-front h2 {
                color: #a5b4fc; /* Indigo-300 on dark background */
            }

            p#meaningContent {
                background-color: #115e59; /* Darker Teal/Cyan */
                color: #e0f2f1;
            }
            p#exampleContent {
                background-color: #7f1d1d; /* Darker Red/Pink */
                color: #fca5a5;
            }
        }

        .flashcard-front h2 {
            font-size: 2.5rem;
            font-weight: 700;
            color: #1e3a8a; /* Blue-800 in light mode */
            text-align: center;
        }

        /* Responsive adjustments */
        @media (max-width: 640px) {
            #flashcard {
                /* New mobile height: increased from 350px to 370px (approx 5% more) */
                height: 370px;
                max-width: 95vw;
            }
            .flashcard-front h2 {
                font-size: 2rem;
            }
        }

        /* Styles for the side navigation buttons */
        .side-nav-button {
            width: 100px;
            height: 50px;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center p-4" style="font-family: 'Inter', sans-serif;">

    <!-- Logo and Title Group -->
    <div class="flex flex-col items-center mb-6">
        <!-- Logo (Make sure to use a relative path) -->
        <img src="../../img/statmania_logo.png" alt="Stat Mania Logo" class="w-20 h-auto mb-2">
        <!-- New Title -->
        <h1 class="text-3xl font-bold text-gray-800 dark:text-gray-100 text-center">
            Stat Mania GRE Flashcards
        </h1>
    </div>

    <!-- Filter Toggle and Global Controls: Now centered -->
    <div id="filterControlBar" class="w-full max-w-4xl mb-4 flex justify-center items-center px-2 sm:px-0">

        <!-- Group: Home, Shuffle, Filter -->
        <div class="flex space-x-4 items-center">

            <!-- 1. Home Link (Icon + Text) -->
            <a href="../" class="flex items-center px-4 py-2 text-indigo-600 hover:text-indigo-800 font-semibold rounded-full transition duration-300 text-sm sm:text-base" title="Home">
                <i class="fas fa-home mr-1"></i> Home
            </a>

            <!-- 2. Shuffle Button (Icon Only) - Blue when on, Grey when off -->
            <button id="shuffleButton" onclick="shuffleCards()"
                class="p-3 text-white font-semibold rounded-full shadow-lg transition duration-300 text-lg flex items-center justify-center
                       bg-blue-600 hover:bg-blue-700 disabled:bg-gray-500 disabled:hover:bg-gray-500 disabled:opacity-70"
                title="Shuffle Cards">
                <i class="fas fa-random"></i>
            </button>

            <!-- 3. Filter Menu Icon Button (Icon Only) -->
            <button id="filterToggleButton" onclick="toggleFilters()"
                    class="p-3 bg-indigo-500 text-white rounded-full shadow-lg hover:bg-indigo-600 transition duration-300"
                    title="Toggle Filters">
                <i class="fas fa-filter text-lg"></i>
            </button>
        </div>
    </div>
    <!-- End Filter Toggle and Global Controls -->


    <!-- Filter Menu Container (Hidden by default) -->
    <div id="filterContainer" class="hidden w-full max-w-4xl mb-6 p-4 bg-white rounded-xl shadow-lg dark:bg-gray-800 border border-gray-200 dark:border-gray-700">
        <h3 class="text-xl font-bold text-gray-700 mb-4 dark:text-gray-300">Filter Options</h3>

        <!-- Desktop Layout (sm: and up) - Centered 60% Width -->
        <div class="hidden sm:flex flex-row items-end justify-center w-full space-x-4">

            <!-- Letter Dropdown (20%) -->
            <div class="w-[20%] min-w-[120px]">
                <label for="letterFilterSelect" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Letter (20%)</label>
                <select id="letterFilterSelect" onchange="applyFilters()"
                    class="w-full p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white">
                    <option value="ALL">ALL</option>
                    <!-- Options will be generated by JavaScript -->
                </select>
            </div>

            <!-- Serial Range Inputs (20% total: 10% From, 10% To) -->
            <div class="flex items-end w-[20%] min-w-[120px] space-x-1">
                <div class="flex-1">
                    <label for="startSerial" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">From (10%)</label>
                    <input type="number" id="startSerial" placeholder="Start"
                        class="w-full p-2 border border-gray-300 rounded-lg shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white min-w-0" min="1">
                </div>
                <div class="flex-1">
                    <label for="endSerial" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">To (10%)</label>
                    <input type="number" id="endSerial" placeholder="End"
                        class="w-full p-2 border border-gray-300 rounded-lg shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white min-w-0">
                </div>
            </div>

            <!-- Apply Button (10%) - Fixed height to align with inputs -->
            <button onclick="applyFilters()"
                    class="w-[10%] h-[40px] bg-indigo-500 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-600 transition duration-300 whitespace-nowrap text-sm min-w-max">
                Apply (10%)
            </button>

            <!-- Reset Button (10%) - Fixed height to align with inputs -->
            <button onclick="resetFilters()"
                    class="w-[10%] h-[40px] bg-gray-500 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-300 whitespace-nowrap text-sm min-w-max">
                Reset (10%)
            </button>
        </div>

        <!-- Mobile Layout (default, column stacked) -->
        <div class="flex flex-col sm:hidden gap-4">
            <!-- Letter Dropdown -->
            <div>
                <label for="letterFilterSelect" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Filter by Initial Letter:</label>
                <select id="letterFilterSelect" onchange="applyFilters()" class="w-full p-2 border border-gray-300 rounded-lg shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white">
                    <option value="ALL">ALL Words</option>
                </select>
            </div>

            <!-- Serial Range and Buttons -->
            <div>
                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Filter by Word Serial Index:</label>
                <div class="flex items-center space-x-2">
                    <input type="number" id="startSerial" placeholder="From (e.g., 1)" class="w-1/2 p-2 border border-gray-300 rounded-lg shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white min-w-0" min="1">
                    <input type="number" id="endSerial" placeholder="To (e.g., 50)" class="w-1/2 p-2 border border-gray-300 rounded-lg shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white min-w-0">
                </div>
                <div class="flex mt-2 space-x-2">
                    <button onclick="applyFilters()" class="flex-1 p-2 bg-indigo-500 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-600 transition duration-300">
                        Apply
                    </button>
                    <button onclick="resetFilters()" class="flex-1 p-2 bg-gray-500 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-300">
                        Reset
                    </button>
                </div>
            </div>
        </div>
        <!-- End Mobile Layout -->

        <p id="wordCountMessage" class="mt-2 text-xs text-gray-500 dark:text-gray-400">Total words: 0. Showing: 0</p>
    </div>
    <!-- End Filter Menu -->

    <!-- Main Card & Navigation Container -->
    <div class="flex items-center justify-center w-full max-w-4xl mb-8">

        <!-- Previous Word Button (Left) -->
        <button id="previousCardButton" onclick="loadPreviousCard()"
            class="side-nav-button mr-4 p-2 bg-gray-500 text-white font-semibold rounded-full shadow-lg hover:bg-gray-600 transition duration-300 disabled:opacity-50 text-xl flex items-center justify-center sm:text-2xl"
            disabled title="Previous Word">
            <i class="fas fa-arrow-left"></i>
        </button>

        <!-- Flashcard -->
        <div id="flashcard" touch-action="none">
            <div id="cardInner" class="flashcard-inner" onclick="flipCard()">
                <!-- Card Front -->
                <div id="cardFront" class="flashcard-front">
                    <!-- loadingText is visible by default -->
                    <p id="loadingText" class="text-lg text-gray-500">Loading Words...</p>
                    <!-- mainWord is hidden by default, shown once data loads -->
                    <h2 id="mainWord" class="hidden"></h2>
                </div>

                <!-- Card Back -->
                <div id="cardBack" class="flashcard-back">
                    <!-- Scrollable content wrapper (Text is centered via CSS) -->
                    <div class="card-content-scroll">

                        <!-- Meaning Content Only -->
                        <p id="meaningContent" class="text-gray-700 font-medium text-lg mb-4"></p>

                        <!-- Example Content Only, Separated Visually -->
                        <p id="exampleContent" class="italic text-gray-500 border-t border-gray-200 pt-3 mt-3"></p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Next Word Button (Right) -->
        <button id="nextCardButton" onclick="loadNextCard()"
            class="side-nav-button ml-4 p-2 bg-indigo-600 text-white font-semibold rounded-full shadow-lg hover:bg-indigo-700 transition duration-300 disabled:opacity-50 text-xl flex items-center justify-center sm:text-2xl"
            title="Next Word">
            <i class="fas fa-arrow-right"></i>
        </button>
    </div>
    <!-- End Main Card & Navigation Container -->

    <script>
        // MOCK DATA: Used for immediate functionality since we cannot access local files.
        const MOCK_CSV_DATA = `
word,meaning,part_of_speech,example
ephemeral,"lasting for a very short time",adjective,"The beauty of the cherry blossoms is ephemeral, lasting only a few weeks."
insipid,"lacking flavor or zest; dull",adjective,"The film was insipid, with a predictable plot and uninspired acting."
obfuscate,"to make obscure, unclear, or unintelligible",verb,"The politician attempted to obfuscate the issue with vague responses."
capricious,"given to sudden and unaccountable changes of mood or behavior",adjective,"The investors were wary of the CEO's capricious decision-making."
serendipity,"the occurrence and development of events by chance in a happy or beneficial way",noun,"Finding the lost ring was a moment of pure serendipity."
alacrity,"brisk and cheerful readiness",noun,"She accepted the new assignment with alacrity."
tenuous,"very weak or slight",adjective,"The tenuous link between the evidence and the suspect quickly broke down."
paradox,"a seemingly absurd or self-contradictory statement or proposition that when investigated or explained may prove to be well founded or true",noun,"The paradox is that the more you give, the more you have."
ubiquitous,"present, appearing, or found everywhere",adjective,"Smartphones are ubiquitous in modern society."
zeitgeist,"the defining spirit or mood of a particular period of history as shown by the ideas and beliefs of the time",noun,"The film perfectly captured the liberal zeitgeist of the 1960s."
juxtaposition,"the fact of two things being seen or placed close together with contrasting effect",noun,"The juxtaposition of the old church and the new skyscraper was striking."
bifurcate,"divide into two branches or forks",verb,"The road bifurcates near the river."
deleterious,"causing harm or damage",adjective,"The lack of sleep had a deleterious effect on his focus."
fecund,"producing or capable of producing an abundance of offspring or new growth; fertile",adjective,"The artist's fecund imagination produced masterpiece after masterpiece."
garrulous,"excessively talkative, especially on trivial matters",adjective,"The garrulous taxi driver kept recounting tales of his youth."
`;

        const CSV_URL = 'magoosh_az_words.csv';

        let allWords = [];
        let filteredWords = [];
        let currentWordIndex = -1;
        let wordHistory = [];
        const ALPHABET = Array.from({ length: 26 }, (_, i) => String.fromCharCode(65 + i));

        // --- Utility Functions ---

        const parseCSV = (text) => {
            try {
                const lines = text.trim().split('\n').filter(line => line.length > 0);
                if (lines.length <= 1) return [];

                const headers = lines[0].split(',').map(h => h.trim());
                const dataLines = lines.slice(1);
                const results = [];

                dataLines.forEach(line => {
                    const values = [];
                    let value = '';
                    let inQuotes = false;
                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];

                        if (char === '"') {
                            inQuotes = !inQuotes;
                        } else if (char === ',' && !inQuotes) {
                            values.push(value.trim().replace(/^"|"$/g, ''));
                            value = '';
                        } else {
                            value += char;
                        }
                    }
                    values.push(value.trim().replace(/^"|"$/g, ''));

                    if (values.length === headers.length) {
                        const row = {};
                        headers.forEach((header, index) => {
                            row[header] = values[index];
                        });
                        results.push(row);
                    } else {
                        console.warn('Skipping malformed row:', line);
                    }
                });
                return results;

            } catch (error) {
                console.error("Error parsing CSV data:", error);
                return [];
            }
        };

        const shuffleArray = (array) => {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));

                const temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        };

        // --- Toggle Function ---
        window.toggleFilters = function() {
            const container = document.getElementById('filterContainer');
            container.classList.toggle('hidden');
        }

        // --- Core Application Logic ---

        window.shuffleCards = function() {
            if (filteredWords.length > 0) {
                // 1. Perform the shuffle
                shuffleArray(filteredWords);

                // 2. Reset the pointers and history
                currentWordIndex = 0;
                wordHistory = [];

                // 3. Load the new current card
                loadCard(currentWordIndex, true);
            }
        };

        window.resetFilters = function() {
            document.getElementById('letterFilterSelect').value = 'ALL';
            document.getElementById('startSerial').value = 1;
            document.getElementById('endSerial').value = allWords.length;
            applyFilters();
        };

        window.applyFilters = function() {
            const letter = document.getElementById('letterFilterSelect').value;
            const totalWords = allWords.length;

            let start = parseInt(document.getElementById('startSerial').value);
            let end = parseInt(document.getElementById('endSerial').value);

            start = (isNaN(start) || start < 1) ? 1 : start;
            end = (isNaN(end) || end > totalWords) ? totalWords : end;

            if (end < start) end = start;

            const startIndex = start - 1;
            const endIndex = end;

            let rangeWords = allWords.slice(startIndex, endIndex);

            if (letter !== 'ALL') {
                 filteredWords = rangeWords.filter(word => word.word && word.word.toUpperCase().startsWith(letter));
            } else {
                filteredWords = rangeWords;
            }

            const wordCountMessage = document.getElementById('wordCountMessage');
            wordCountMessage.textContent = `Total words: ${totalWords}. Showing: ${filteredWords.length} (Serial ${start} to ${end}).`;


            currentWordIndex = -1;
            wordHistory = [];

            const loadingText = document.getElementById('loadingText');
            const mainWord = document.getElementById('mainWord');

            if (filteredWords.length > 0) {
                currentWordIndex = 0;
                loadCard(currentWordIndex, true);

                loadingText.classList.add('hidden');
                mainWord.classList.remove('hidden');
            } else {
                mainWord.classList.add('hidden');
                loadingText.textContent = `No words found matching the current filters.`;
                loadingText.classList.remove('hidden');
            }
            updateButtonStates();
        };

        const loadCard = (index, trackHistory = true) => {
            // Ensure card is always face up when a new word is loaded
            document.getElementById('cardInner').classList.remove('flipped');

            const wordData = filteredWords[index];

            if (trackHistory) {
                 if (wordHistory.length === 0 || wordHistory[wordHistory.length - 1] !== index) {
                    wordHistory.push(index);
                 }
            }

            if (wordHistory.length > 50) {
                wordHistory.shift();
            }

            document.getElementById('mainWord').textContent = wordData.word || 'Word Missing';
            document.getElementById('meaningContent').textContent = wordData.meaning || 'No meaning provided.';
            document.getElementById('exampleContent').textContent = wordData.example || 'No example provided.';

            updateButtonStates();
        }

        window.loadNextCard = function() {
            if (filteredWords.length === 0) {
                updateButtonStates();
                return;
            }

            currentWordIndex = (currentWordIndex + 1) % filteredWords.length;

            loadCard(currentWordIndex, true);
        };

        window.loadPreviousCard = function() {
            if (wordHistory.length > 1) {
                // Remove the current card index
                wordHistory.pop();
                // Get the index of the card before the current one
                const previousIndex = wordHistory[wordHistory.length - 1];

                currentWordIndex = previousIndex;
                loadCard(currentWordIndex, false);
            } else {
                updateButtonStates();
            }
        };

        const updateButtonStates = () => {
            document.getElementById('previousCardButton').disabled = wordHistory.length <= 1 || filteredWords.length === 0;
            document.getElementById('nextCardButton').disabled = filteredWords.length === 0;
            // Shuffle button is only disabled when there are no words to shuffle
            document.getElementById('shuffleButton').disabled = filteredWords.length === 0;
        };

        const generateFilterUI = () => {
            const selectElement = document.getElementById('letterFilterSelect');

            while (selectElement.options.length > 1) {
                selectElement.remove(1);
            }

            ALPHABET.forEach(letter => {
                const option = document.createElement('option');
                option.value = letter;
                option.textContent = letter;
                selectElement.appendChild(option);
            });
        };


        // --- Data Loading and Initialization ---
        const loadWords = async () => {
            const loadingText = document.getElementById('loadingText');
            const mainWord = document.getElementById('mainWord');

            loadingText.classList.remove('hidden');
            mainWord.classList.add('hidden');
            loadingText.textContent = 'Loading Words...';

            let csvText = MOCK_CSV_DATA;

            try {
                const response = await fetch(CSV_URL);
                if (!response.ok) {
                    throw new Error(`Status: ${response.status} ${response.statusText}`);
                }
                csvText = await response.text();
            } catch (error) {
                console.warn(`Failed to fetch file at '${CSV_URL}'. Using Mock Data.`);
            }

            allWords = parseCSV(csvText);
            allWords = allWords.filter(word => word.word && word.word.trim() !== '');

            generateFilterUI();

            if (allWords.length > 0) {
                document.getElementById('startSerial').value = 1;
                document.getElementById('endSerial').value = allWords.length;

                applyFilters();

            } else {
                loadingText.textContent = 'No valid word data found.';
                loadingText.classList.add('hidden');
                mainWord.classList.add('hidden');
            }
            updateButtonStates();
        };

        window.flipCard = function() {
            const cardInner = document.getElementById('cardInner');
            if (filteredWords.length > 0) {
                 cardInner.classList.toggle('flipped');
            }
        }

        // --- Swipe Navigation Logic for Mobile (unchanged logic) ---
        let touchstartX = 0;
        let touchendX = 0;
        const SWIPE_THRESHOLD = 75;

        function handleGesture() {
            const diffX = touchendX - touchstartX;

            if (Math.abs(diffX) > SWIPE_THRESHOLD) {
                if (diffX < 0) {
                    // Swiped Left (Next Card)
                    window.loadNextCard();
                } else {
                    // Swiped Right (Previous Card)
                    window.loadPreviousCard();
                }
            }
        }

        const cardElement = document.getElementById('flashcard');

        cardElement.addEventListener('touchstart', e => {
            touchstartX = e.changedTouches[0].screenX;
        });

        cardElement.addEventListener('touchend', e => {
            touchendX = e.changedTouches[0].screenX;
            handleGesture();
        });

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', loadWords);

    </script>
</body>
</html>
